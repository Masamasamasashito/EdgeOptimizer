/**
 * ----------------------------------------------------------
 * Edge Optimizer
 * Request Engine Core - Shared Code Module for Cloudflare Workers
 *
 * Crafted by Nishi Labo | https://4649-24.com
 * ----------------------------------------------------------
 *
 * This module contains shared code used by all CF Workers Request Engine implementations.
 * TypeScript port of RequestEngine/common/request_engine_core.py
 *
 * Note: This file is bundled with platform-specific handlers by esbuild during build.
 * Do NOT add platform-specific imports or code here.
 */

import type {
  JsonRecord,
  StringRecord,
  ResourceInfo,
  ExecutionResultParams,
} from "../global/funcfiles/src/_01_types";

// ======================================================================
// Constants
// ======================================================================

export const CONSTANTS = {
  EO_HEADER_NAME: "x-eo-re",
  EO_HEADER_VALUE: "cloudflare",
  EO_DEFAULT_AREA: "Cloudflare_global",
  // Header keys to exclude from forwarding/logging (lowercase)
  EO_IGNORED_HEADERS: ["host", "httprequestnumber"],
  EO_COMMON_RESP_HEADERS: {
    "content-type": "application/json;charset=utf-8",
    "Cache-Control": "no-store",
  } as const,
};

// Workers fetch API does not expose outgoing connection protocol/TLS information.
// request.cf.httpProtocol / request.cf.tlsVersion only provide incoming (client -> Worker) info.
// See: https://developers.cloudflare.com/workers/runtime-apis/request/#incomingrequestcfproperties
// See: https://developers.cloudflare.com/workers/runtime-apis/response/
// See: https://developers.cloudflare.com/workers/runtime-apis/fetch/
export const PROTOCOL_UNAVAILABLE_MESSAGE =
  "unavailable: Workers fetch API does not expose outgoing connection info (https://developers.cloudflare.com/workers/runtime-apis/request/#incomingrequestcfproperties)";

// ======================================================================
// Token Calculation (SHA-256)
// ======================================================================

/**
 * Calculate request token (SHA-256 hash)
 *
 * Used to verify against token generated by n8n workflow.
 * Formula: SHA-256(url + request_secret)
 *
 * Matches RequestEngine/common/request_engine_core.py _calc_token()
 *
 * @param url - Target URL
 * @param secret - Request secret (from Cloudflare Workers Secrets)
 * @returns 64-character hexadecimal hash value (lowercase)
 */
export async function calcToken(url: string, secret: string): Promise<string> {
  const encoder = new TextEncoder();
  const data = encoder.encode(url + secret);
  const hashBuffer = await crypto.subtle.digest("SHA-256", data);
  const hashArray = Array.from(new Uint8Array(hashBuffer));
  return hashArray.map((b) => b.toString(16).padStart(2, "0")).join("");
}

// ======================================================================
// URL Extension Determination
// ======================================================================

/**
 * Get extension from URL (removing query parameters and anchors)
 *
 * Matches RequestEngine/common/request_engine_core.py _get_url_extension()
 *
 * @param url - Target URL
 * @returns Extension string (lowercase) or null
 */
export function getUrlExtension(url: string): string | null {
  try {
    const parsed = new URL(url);
    const path = parsed.pathname;
    if (!path) return null;
    if (path.includes(".")) {
      const ext = path.split(".").pop()?.toLowerCase() ?? null;
      // Check if extension is valid string (alphanumeric only)
      if (ext && /^[a-z0-9]+$/.test(ext)) {
        return ext;
      }
    }
    return null;
  } catch {
    return null;
  }
}

// ======================================================================
// Determine Resource Type Based on URL Type and Extension
// ======================================================================

/**
 * Determine resource type from urltype and URL extension
 *
 * Maintains consistency with n8n workflow
 * (160 node: Asset / MainDoc / Exception Classification)
 *
 * Matches RequestEngine/common/request_engine_core.py _determine_resource_type()
 *
 * Asset extensions:
 * - Images: jpg, jpeg, gif, png, webp, avif, svg, ico
 * - CSS: css
 * - JS: js
 * - Fonts: woff, woff2, ttf, otf, eot
 * - Videos: mp4, webm, ogg, mov
 *
 * resource_category:
 * - "html", "image", "css", "js", "font", "video", "other"
 *
 * @param urltype - URL type from n8n ("main_document", "asset", "exception", or null)
 * @param url - Target URL
 * @returns Resource information object
 */
export function determineResourceType(
  urltype: string | null,
  url: string,
): ResourceInfo {
  const resourceInfo: ResourceInfo = {
    urltype,
    url_extension: null,
    resource_category: null,
  };

  const ext = getUrlExtension(url);
  resourceInfo.url_extension = ext;

  if (urltype === "main_document") {
    resourceInfo.resource_category = "html";
  } else if (urltype === "asset") {
    const imageExts = ["jpg", "jpeg", "gif", "png", "webp", "avif", "svg", "ico"];
    const cssExts = ["css"];
    const jsExts = ["js"];
    const fontExts = ["woff", "woff2", "ttf", "otf", "eot"];
    const videoExts = ["mp4", "webm", "ogg", "mov"];

    if (ext && imageExts.includes(ext)) {
      resourceInfo.resource_category = "image";
    } else if (ext && cssExts.includes(ext)) {
      resourceInfo.resource_category = "css";
    } else if (ext && jsExts.includes(ext)) {
      resourceInfo.resource_category = "js";
    } else if (ext && fontExts.includes(ext)) {
      resourceInfo.resource_category = "font";
    } else if (ext && videoExts.includes(ext)) {
      resourceInfo.resource_category = "video";
    } else {
      resourceInfo.resource_category = "other";
    }
  } else if (urltype === "exception") {
    resourceInfo.resource_category = "exception";
  }

  return resourceInfo;
}

// ======================================================================
// Prepare Request Headers
// ======================================================================

/**
 * Normalize request headers
 * - Exclude specific headers (Host, httpRequestNumber)
 * - Attach WAF bypass header (x-eo-re)
 *
 * @param inputHeaders - Raw headers from request
 * @returns Normalized headers
 */
export function prepareRequestHeaders(inputHeaders: unknown): StringRecord {
  const headers: StringRecord = {};

  if (typeof inputHeaders === "object" && inputHeaders !== null) {
    for (const [key, value] of Object.entries(inputHeaders)) {
      if (typeof value !== "string") continue;

      const lowerKey = key.toLowerCase();
      if (CONSTANTS.EO_IGNORED_HEADERS.includes(lowerKey)) continue;

      headers[key] = value;
    }
  }

  // Attach WAF bypass header
  headers[CONSTANTS.EO_HEADER_NAME] = CONSTANTS.EO_HEADER_VALUE;

  return headers;
}

// ======================================================================
// Build Flat Result
// ======================================================================

/**
 * Build response in flat JSON structure
 * All keys are normalized to lowercase.
 *
 * Output key order matches RequestEngine/common/request_engine_core.py _build_flat_result()
 *
 * @param params - Execution result parameters
 * @returns Flat JSON object
 */
export function buildFlatResult(params: ExecutionResultParams): JsonRecord {
  const {
    statusCode,
    statusMessage,
    duration_ms,
    ttfb_ms,
    content_length_bytes,
    targetUrl,
    httpRequestNumber,
    httpRequestUUID,
    httpRequestRoundID,
    reqHeaders,
    respHeaders,
    extraError,
    area,
    executionId,
    requestStartTimestamp,
    requestEndTimestamp,
  } = params;

  if (!area) {
    throw new Error("area parameter is required - must be passed from platform handler");
  }

  const result: JsonRecord = {};

  // ==================================================================
  // 1. Basic HTTP Information
  // ==================================================================
  result["headers.general.status-code"] = statusCode;
  result["headers.general.status-message"] = statusMessage;
  result["headers.general.request-url"] = targetUrl;
  result["headers.general.http-request-method"] = "GET";

  // ==================================================================
  // 2. Request Identification Information
  // ==================================================================
  if (httpRequestNumber !== undefined && httpRequestNumber !== null) {
    result["eo.meta.http-request-number"] = httpRequestNumber;
  }
  if (httpRequestUUID !== undefined && httpRequestUUID !== null) {
    result["eo.meta.http-request-uuid"] = httpRequestUUID;
  }
  if (httpRequestRoundID !== undefined && httpRequestRoundID !== null) {
    result["eo.meta.http-request-round-id"] = httpRequestRoundID;
  }

  // ==================================================================
  // 3. Execution Environment / Timestamp Information
  // ==================================================================
  result["eo.meta.area"] = area;
  if (executionId !== undefined && executionId !== null) {
    result["eo.meta.execution-id"] = executionId;
  }
  if (requestStartTimestamp !== undefined && requestStartTimestamp !== null) {
    result["eo.meta.request-start-timestamp"] = requestStartTimestamp;
  }
  if (requestEndTimestamp !== undefined && requestEndTimestamp !== null) {
    result["eo.meta.request-end-timestamp"] = requestEndTimestamp;
  }

  // ==================================================================
  // 4. Protocol Information
  // ==================================================================
  result["eo.meta.http-protocol-version"] = PROTOCOL_UNAVAILABLE_MESSAGE;
  result["eo.meta.tls-version"] = PROTOCOL_UNAVAILABLE_MESSAGE;

  // ==================================================================
  // 5. Measure (inlined, Phase 1 does not use extension registry)
  //    Matches RequestEngine/common/extensions/_ext_measure.py build_output()
  // ==================================================================
  if (duration_ms !== undefined) {
    result["eo.measure.duration-ms"] = Math.round(duration_ms * 100) / 100;
  }
  if (ttfb_ms !== undefined) {
    result["eo.measure.ttfb-ms"] = Math.round(ttfb_ms * 100) / 100;
  }
  if (content_length_bytes !== undefined) {
    result["eo.measure.actual-content-length"] = content_length_bytes;
  }

  // ==================================================================
  // 9. Request Headers (sorted by key)
  // ==================================================================
  for (const key of Object.keys(reqHeaders).sort()) {
    result[`headers.request-headers.${key.toLowerCase()}`] = reqHeaders[key];
  }

  // ==================================================================
  // 10. Response Headers (sorted by key)
  // ==================================================================
  if (respHeaders) {
    const entries: [string, string][] =
      respHeaders instanceof Headers
        ? Array.from(respHeaders.entries())
        : Object.entries(respHeaders as StringRecord);

    entries.sort((a, b) => a[0].localeCompare(b[0]));

    for (const [key, value] of entries) {
      if (typeof value === "string") {
        result[`headers.response-headers.${key.toLowerCase()}`] = value;
      }
    }
  }

  // ==================================================================
  // 11. Complement content-length header
  // ==================================================================
  if (content_length_bytes !== undefined) {
    const clKey = "headers.response-headers.content-length";
    if (!(clKey in result) || !result[clKey]) {
      result[clKey] = String(content_length_bytes);
    }
  }

  // ==================================================================
  // Error information (appended at the end if present)
  // ==================================================================
  if (extraError) {
    Object.assign(result, extraError);
  }

  return result;
}
