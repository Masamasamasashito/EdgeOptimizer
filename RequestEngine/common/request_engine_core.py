# ----------------------------------------------------
# Edge Optimizer
# Request Engine Core - Shared Code Module
# Crafted by Nishi Labo | https://4649-24.com
# ----------------------------------------------------
#
# This module contains shared code used by all Request Engine implementations:
# - AWS Lambda
# - Azure Functions
# - GCP Cloud Run
#
# Note: This file is merged with platform-specific handlers during deployment.
# Do NOT add platform-specific imports or code here.

# ======================================================================
# Configuration Constants
# ======================================================================

HTTP_REQUEST_TIMEOUT = 10  # HTTP request timeout (seconds)
# 10 seconds is sufficient for warmup purposes (reduced from 30 seconds for cost optimization)

MAX_CONTENT_SIZE_FOR_ANALYSIS = 5 * 1024 * 1024  # 5MB
# Contents exceeding this size will skip analysis (memory protection)
# Considering memory limits of serverless platforms

# ======================================================================
# Retry Configuration
# ======================================================================
MAX_RETRY_ATTEMPTS = 2  # Maximum retry count (total 3 attempts including initial)
# Example: Initial + 2 retries = 3 total attempts

RETRY_INITIAL_DELAY = 0.5  # Initial retry delay (seconds)
# 1st retry: 0.5s wait

RETRY_BACKOFF_MULTIPLIER = 2.0  # Exponential backoff multiplier
# Retry interval calculation: delay = RETRY_INITIAL_DELAY * (RETRY_BACKOFF_MULTIPLIER ** attempt)
# Example: 1st: 0.5s, 2nd: 1.0s, 3rd: 2.0s

RETRYABLE_STATUS_CODES = {500, 502, 503, 504}  # HTTP status codes eligible for retry
# 5xx server errors are likely temporary issues, so they are retry targets
# 4xx client errors are not retry targets (retrying won't resolve them)


# ======================================================================
# Extension Registry (拡張機能レジストリ)
# ======================================================================
# 拡張機能を登録・管理するためのレジストリ
# 各拡張機能は _ext_*.py ファイルで定義され、デプロイ時にマージされる
#
# 拡張機能の追加方法:
# 1. RequestEngine/common/extensions/_ext_<name>.py を作成
# 2. ファイル内で EXTENSION_NAME, EXTENSION_PREFIX, build_output() を定義
# 3. ファイル末尾で register_extension() を呼び出す
# 4. GitHub Actions のマージスクリプトに新しいファイルを追加

# 2階層の辞書形式で拡張機能を管理
_EXTENSION_REGISTRY: Dict[str, Dict[str, Any]] = {}

# EX

"""
_EXTENSION_REGISTRY = {
    # 1階層目: キーは「拡張機能の名前」(str)
    "security": {
        # 2階層目: キーは「属性名」(str)
        "prefix": "eo.security.",   # 出力時の接頭辞
        "build_func": _analyze_func, # 実行する関数
        "default_enabled": True      # フラグ
    }
}
"""


def register_extension(
    name: str,
    prefix: str,
    build_func: callable,
    default_enabled: bool = True,
) -> None:
    """
    拡張機能を登録する

    Args:
        name: 拡張機能名 (例: "measure", "performance", "security")
        prefix: 出力キーのプレフィックス (例: "eo.measure.")
        build_func: 出力を生成する関数 (context: dict) -> dict
        default_enabled: デフォルトで有効かどうか
    """
    _EXTENSION_REGISTRY[name] = {
        "prefix": prefix,
        "build_func": build_func,
        "default_enabled": default_enabled,
    }


def get_registered_extensions() -> Dict[str, Dict[str, Any]]:
    """登録済み拡張機能の一覧を取得"""
    return _EXTENSION_REGISTRY.copy()


def build_extension_output(
    name: str,
    context: Dict[str, Any],
) -> Dict[str, Any]:
    """
    指定した拡張機能の出力を生成する

    Args:
        name: 拡張機能名
        context: 拡張機能に渡すコンテキスト

    Returns:
        Dict[str, Any]: 拡張機能の出力 (プレフィックス付きのキー)
    """
    if name not in _EXTENSION_REGISTRY:
        return {}

    ext = _EXTENSION_REGISTRY[name]
    try:
        raw_output = ext["build_func"](context)
        # プレフィックスを付けて返す
        prefix = ext["prefix"]
        return {f"{prefix}{k}": v for k, v in raw_output.items()}
    except Exception as e:
        logging.warning(f"Extension '{name}' failed: {str(e)}")
        return {f"{ext['prefix']}error": str(e)}


# ======================================================================
# Token Calculation (SHA-256)
# ======================================================================
def _calc_token(url: str, secret: str) -> str:
    """
    Calculate request token (SHA-256 hash)

    Used to verify against token generated by n8n workflow.
    Formula: SHA-256(url + request_secret)

    Args:
        url: Target URL
        secret: Request secret (retrieved from cloud secret manager)

    Returns:
        str: 64-character hexadecimal hash value (lowercase)

    Note:
        - n8n side uses N8N_EO_REQUEST_SECRET
        - Cloud side uses platform-specific secret key
        - Both values must be identical
    """
    return hashlib.sha256(f"{url}{secret}".encode()).hexdigest()


# ======================================================================
# Analyze Security Headers
# ======================================================================
def _analyze_security_headers(res_headers: Dict[str, str], target_url: str) -> Dict[str, Any]:
    """
    Analyze security headers and return metrics
    Included in Core Web Vitals / PageSpeed Insights / Security metrics
    """
    security = {}
    security["is_https"] = target_url.startswith("https://")

    headers_lower = {k.lower(): v for k, v in res_headers.items()}

    # Security header definitions (header name -> key name mapping)
    security_headers = {
        "strict-transport-security": "hsts",
        "content-security-policy": "csp",
        "x-content-type-options": "x_content_type_options",
        "x-frame-options": "x_frame_options",
        "x-xss-protection": "x_xss_protection",
        "referrer-policy": "referrer_policy",
        "public-key-pins": "hpkp",
    }

    # Check each security header
    for header_name, key_prefix in security_headers.items():
        header_value = headers_lower.get(header_name)
        security[f"{key_prefix}_present"] = header_value is not None
        if header_value:
            security[f"{key_prefix}_value"] = header_value

    # Permissions-Policy (formerly Feature-Policy) - Special handling
    permissions_policy = headers_lower.get("permissions-policy") or headers_lower.get("feature-policy")
    security["permissions_policy_present"] = permissions_policy is not None
    if permissions_policy:
        security["permissions_policy_value"] = permissions_policy

    return security


# ======================================================================
# Get HTTP Protocol Version
# ======================================================================
def _get_http_protocol_version(response: requests.Response) -> Optional[str]:
    """
    Get HTTP protocol version (HTTP/1.1, HTTP/2, HTTP/3, etc.)
    Returns error message with reason if determination is difficult
    """
    if not hasattr(response, 'raw') or response.raw is None:
        return "ERROR: Cannot determine HTTP protocol version. The response object does not have a 'raw' attribute or it is None. The 'raw' attribute is required to access the underlying HTTP version information."

    try:
        version = getattr(response.raw, 'version', None)
        if version is None:
            version = getattr(response.raw, '_http_version', None)
        if version:
            if version == 11:
                return "HTTP/1.1"
            elif version == 20:
                return "HTTP/2"
            elif version == 30:
                return "HTTP/3"
            elif isinstance(version, (int, float)):
                return f"HTTP/{version/10}"
            else:
                return str(version)
        else:
            return "ERROR: Cannot determine HTTP protocol version. The response.raw object does not have 'version' or '_http_version' attributes. These attributes are required to determine the HTTP protocol version, but they are not available in this response object."
    except AttributeError as e:
        return f"ERROR: Cannot determine HTTP protocol version due to AttributeError. Accessing the HTTP version attribute failed: {str(e)}. The response object structure may not match the expected format."
    except TypeError as e:
        return f"ERROR: Cannot determine HTTP protocol version due to TypeError. Type mismatch occurred while accessing the HTTP version: {str(e)}."
    except Exception as e:
        return f"ERROR: Cannot determine HTTP protocol version due to unexpected error ({type(e).__name__}): {str(e)}."


# ======================================================================
# Get TLS Version
# ======================================================================
def _get_tls_version(response: requests.Response, target_url: str) -> Optional[str]:
    """
    Get TLS version
    Returns value with reason on failure
    """
    if not target_url.startswith("https://"):
        return "unknown: not_https"
    if not hasattr(response, 'raw') or response.raw is None:
        return "unknown: response_raw_not_available"

    try:
        connection = getattr(response.raw, '_connection', None)
        if connection is None:
            return "unknown: connection_not_found"

        sock = getattr(connection, 'sock', None)
        if sock is None:
            return "unknown: sock_not_found"
        if not isinstance(sock, ssl.SSLSocket):
            return f"unknown: sock_not_ssl (type: {type(sock).__name__})"

        try:
            ssl_version_str = sock.version()
            tls_version_map = {
                'TLSv1': 'TLSv1.0',
                'TLSv1.1': 'TLSv1.1',
                'TLSv1.2': 'TLSv1.2',
                'TLSv1.3': 'TLSv1.3',
            }
            for key, value in tls_version_map.items():
                if key in ssl_version_str:
                    return value
            if ssl_version_str:
                return ssl_version_str
            return "unknown: version_string_empty"
        except AttributeError as e:
            return f"unknown: version_method_failed (AttributeError: {str(e)})"
        except TypeError as e:
            return f"unknown: version_method_failed (TypeError: {str(e)})"
        except Exception as e:
            return f"unknown: version_method_failed (Exception: {type(e).__name__}: {str(e)})"
    except AttributeError as e:
        return f"unknown: connection_access_failed (AttributeError: {str(e)})"
    except TypeError as e:
        return f"unknown: connection_access_failed (TypeError: {str(e)})"
    except Exception as e:
        return f"unknown: connection_access_failed (Exception: {type(e).__name__}: {str(e)})"


# ======================================================================
# URL Extension Determination
# ======================================================================
def _get_url_extension(url: str) -> Optional[str]:
    """
    Get extension from URL (removing query parameters and anchors)
    """
    try:
        parsed = urlparse(url)
        path = parsed.path
        if not path:
            return None
        # Extract extension (after last .)
        if '.' in path:
            ext = path.rsplit('.', 1)[-1].lower()
            # Check if extension is valid string (alphanumeric only)
            if ext and ext.isalnum():
                return ext
        return None
    except Exception:
        return None


# ======================================================================
# Determine Resource Type Based on URL Type and Extension
# ======================================================================
def _determine_resource_type(urltype: Optional[str], url: str) -> Dict[str, Any]:
    """
    Determine resource type from urltype and URL extension

    Maintains consistency with n8n workflow (160 node: Asset / MainDoc / Exception Classification)

    Asset extensions:
    - Images: jpg, jpeg, gif, png, webp, avif, svg, ico
    - CSS: css
    - JS: js
    - Fonts: woff, woff2, ttf, otf, eot
    - Videos: mp4, webm, ogg, mov

    resource_category:
    - "html", "image", "css", "js", "font", "video", "other"
    """
    resource_info = {
        "urltype": urltype,
        "url_extension": None,  # Extension (e.g., "woff2", "ttf", "css", "jpg")
        "resource_category": None,  # "html", "image", "css", "js", "font", "video", "other"
    }

    # Get extension
    ext = _get_url_extension(url)
    resource_info["url_extension"] = ext

    # Determination based on urltype
    if urltype == "main_document":
        # If extension is .html/.htm, it's definitely HTML
        if ext in ["html", "htm"]:
            resource_info["resource_category"] = "html"
        else:
            # Even without extension, likely HTML
            resource_info["resource_category"] = "html"

    elif urltype == "asset":
        # Type determination based on extension
        image_exts = ["jpg", "jpeg", "gif", "png", "webp", "avif", "svg", "ico"]
        css_exts = ["css"]
        js_exts = ["js"]
        font_exts = ["woff", "woff2", "ttf", "otf", "eot"]
        video_exts = ["mp4", "webm", "ogg", "mov"]

        if ext in image_exts:
            resource_info["resource_category"] = "image"
        elif ext in css_exts:
            resource_info["resource_category"] = "css"
        elif ext in js_exts:
            resource_info["resource_category"] = "js"
        elif ext in font_exts:
            resource_info["resource_category"] = "font"
        elif ext in video_exts:
            resource_info["resource_category"] = "video"
        else:
            resource_info["resource_category"] = "other"

    elif urltype == "exception":
        resource_info["resource_category"] = "exception"

    return resource_info


# ======================================================================
# Performance Metrics Data Retrieval (CDN Detection Fully Preserved)
# ======================================================================
def _get_performance_metrics(
    Initial_Response_ms: Optional[float],
    content_length_bytes: Optional[int],
    res_headers: Dict[str, str],
    redirect_count: int = 0,
    resource_info: Optional[Dict[str, Any]] = None,
    retry_info: Optional[Dict[str, Any]] = None,
) -> Dict[str, Any]:
    """
    Get performance metrics data (Headers-only metrics)

    Aggregate data related to infrastructure and delivery.
    This version focuses on network-level metrics and header analysis.

    Args:
        Initial_Response_ms: Time To Initial Response (milliseconds)
        content_length_bytes: Response body size (bytes)
        res_headers: Response headers
        redirect_count: Number of redirects
        resource_info: Resource information (urltype, resource_category, etc.)
        retry_info: Retry information

    Returns:
        Dict[str, Any]: Dictionary containing performance metrics
    """
    metrics = {}

    # Initial_Response_ms (already measured)
    if Initial_Response_ms is not None:
        metrics["Initial_Response_ms"] = Initial_Response_ms

    # Compression type
    headers_lower = {k.lower(): v for k, v in res_headers.items()}
    content_encoding = headers_lower.get("content-encoding", "")
    if content_encoding:
        metrics["content_encoding"] = content_encoding

    # Content-Length header value
    content_length_header = headers_lower.get("content-length")
    if content_length_header:
        metrics["content_length_header"] = content_length_header

    # Actual content size
    if content_length_bytes is not None:
        metrics["content_size_bytes"] = content_length_bytes

    # Cache-Control header value
    cache_control = headers_lower.get("cache-control")
    if cache_control:
        metrics["cache_control"] = cache_control

    # ETag header value
    etag = headers_lower.get("etag")
    if etag:
        metrics["etag"] = etag

    # Last-Modified header value
    last_modified = headers_lower.get("last-modified")
    if last_modified:
        metrics["last_modified"] = last_modified

    # Redirect count
    metrics["redirect_count"] = redirect_count

    # CDN detection (ORIGINAL LIST PRESERVED)
    cdn_headers = [
        "cf-ray",  # Cloudflare
        "x-amz-cf-id",  # AWS CloudFront
        "x-nitro-cache",  # NitroCDN (NitroPack)
        "x-nitro-cache-from",  # NitroCDN (NitroPack)
        "x-nitro-rev",  # NitroCDN (NitroPack)
        "x-rl-cache",  # RabbitLoader
        "x-rl-mode",  # RabbitLoader
        "x-rl-modified",  # RabbitLoader
        "x-rl-rule",  # RabbitLoader
        "x-azure-ref",  # Azure Front Door
        "x-azure-fdid",  # Azure Front Door
        "x-azure-clientip",  # Azure Front Door
        "x-azure-socketip",  # Azure Front Door
        "x-azure-requestchain",  # Azure Front Door
        "x-akamai-request-id",  # Akamai
        "x-cache-remote",  # Akamai
        "x-true-cache-key",  # Akamai
        "x-cache-key",  # Akamai
        "x-serial",  # Akamai
        "x-akamai-edgescape",  # Akamai
        "x-check-cacheable",  # Akamai
        "x-vercel-cache",  # Vercel
        "x-vercel-id",  # Vercel
        "x-cache",  # General cache header (may also be used by Akamai)
        "x-served-by",  # Fastly
        "x-fastly-request-id",  # Fastly
    ]
    for header in cdn_headers:
        if header in headers_lower:
            metrics["cdn_header_name"] = header
            metrics["cdn_header_value"] = headers_lower[header]
            break

    # GCP CDN (Cloud CDN / Media CDN) detection
    server_header = headers_lower.get("server", "")
    if "google-edge-cache" in server_header.lower():
        metrics["cdn_header_name"] = "server"
        metrics["cdn_header_value"] = server_header

    # GCP CDN custom header
    if "cdn_cache_status" in headers_lower:
        metrics["cdn_header_name"] = "cdn_cache_status"
        metrics["cdn_header_value"] = headers_lower["cdn_cache_status"]

    # Vercel Server header detection
    if "vercel" in server_header.lower():
        metrics["cdn_header_name"] = "server"
        metrics["cdn_header_value"] = server_header

    # Azure Front Door Via header detection
    via_header = headers_lower.get("via", "")
    if "azure" in via_header.lower():
        metrics["cdn_header_name"] = "via"
        metrics["cdn_header_value"] = via_header

    # Resource information
    if resource_info:
        metrics["resource_urltype"] = resource_info.get("urltype")
        metrics["resource_extension"] = resource_info.get("url_extension")
        metrics["resource_category"] = resource_info.get("resource_category")

    # Retry information
    if retry_info:
        metrics["retry_attempts"] = retry_info.get("retry_attempts", 0)
        if retry_info.get("retry_delays"):
            metrics["retry_delays_ms"] = [round(d * 1000, 2) for d in retry_info.get("retry_delays", [])]
        if retry_info.get("last_error"):
            metrics["retry_last_error"] = retry_info.get("last_error")

    return metrics


# ======================================================================
# Retryable Error Determination
# ======================================================================
def _is_retryable_error(exception: Exception, status_code: Optional[int] = None) -> bool:
    """
    Determine if error is retryable
    Temporary errors (network errors, server errors, etc.) are retry targets.
    """
    if isinstance(exception, (requests.exceptions.ConnectionError, requests.exceptions.Timeout)):
        return True

    if status_code and status_code in RETRYABLE_STATUS_CODES:
        return True

    if isinstance(exception, requests.exceptions.HTTPError):
        if status_code and status_code in RETRYABLE_STATUS_CODES:
            return True

    return False


# ======================================================================
# HTTP Request Execution (with Retry)
# ======================================================================
def _execute_http_request_with_retry(
    target_url: str,
    headers: Dict[str, str],
) -> Tuple[requests.Response, Dict[str, Any]]:
    """
    Execute HTTP request with retry (stream=True)
    Automatically retry for temporary errors.

    Note: stream=True makes requests.get() return when response headers are received
    (before body download). This enables accurate TTFB measurement in the caller.
    The caller MUST consume the body (response.content) and close the response.
    """
    retry_info = {
        "retry_attempts": 0,
        "retry_delays": [],
        "last_error": None,
    }

    last_exception = None
    last_response = None

    for attempt in range(MAX_RETRY_ATTEMPTS + 1):
        try:
            response = requests.get(
                target_url,
                headers=headers,
                timeout=HTTP_REQUEST_TIMEOUT,
                allow_redirects=True,
                stream=True,
            )

            status_code = response.status_code

            if status_code in RETRYABLE_STATUS_CODES and attempt < MAX_RETRY_ATTEMPTS:
                last_response = response
                response.close()
                delay = RETRY_INITIAL_DELAY * (RETRY_BACKOFF_MULTIPLIER ** attempt)
                retry_info["retry_delays"].append(delay)
                time.sleep(delay)
                retry_info["retry_attempts"] += 1
                logging.warning(f"Retry attempt {retry_info['retry_attempts']} for status {status_code}")
                continue

            retry_info["retry_attempts"] = attempt
            return response, retry_info

        except requests.exceptions.RequestException as e:
            last_exception = e
            retry_info["last_error"] = str(e)

            if _is_retryable_error(e) and attempt < MAX_RETRY_ATTEMPTS:
                delay = RETRY_INITIAL_DELAY * (RETRY_BACKOFF_MULTIPLIER ** attempt)
                retry_info["retry_delays"].append(delay)
                time.sleep(delay)
                retry_info["retry_attempts"] += 1
                continue
            else:
                raise

    if last_response: last_response.close()
    if last_exception: raise last_exception
    raise RuntimeError("Maximum retry attempts reached")


# ======================================================================
# Build Flat Result (Renamed Param & Structure Maintained)
# ======================================================================
def _build_flat_result(
    *,
    status_code: int,
    status_message: str,
    duration_ms: float,
    Initial_Response_ms: Optional[float] = None,
    content_length_bytes: Optional[int] = None,
    target_url: str,
    http_request_number: Optional[Any] = None,
    http_request_uuid: Optional[str] = None,
    http_request_round_id: Optional[int] = None,
    req_headers: Dict[str, str],
    res_headers: Dict[str, str],
    tls_version: Optional[str] = None,
    http_protocol_version: Optional[str] = None,
    request_start_timestamp: Optional[float] = None,
    request_end_timestamp: Optional[float] = None,
    execution_id: Optional[str] = None,
    area: Optional[str] = None,
    redirect_count: int = 0,
    resource_info: Optional[Dict[str, Any]] = None,
    retry_info: Optional[Dict[str, Any]] = None,
) -> Dict[str, Any]:
    """
    Build response in flat JSON structure (Pure HTTP Focus)
    All keys are normalized to lowercase.
    """
    if not area:
        raise RuntimeError("area parameter is required - must be passed from platform handler")

    protocol_value = http_protocol_version or "unknown"
    tls_version_value = tls_version or "unknown"

    ordered_result = {}

    # ==================================================================
    # 1. Basic HTTP Information
    # ==================================================================
    ordered_result["headers.general.status-code"] = status_code
    ordered_result["headers.general.status-message"] = status_message
    ordered_result["headers.general.request-url"] = target_url
    ordered_result["headers.general.http-request-method"] = "GET"

    # ==================================================================
    # 2. Request Identification Information
    # ==================================================================
    if http_request_number is not None:
        ordered_result["eo.meta.http-request-number"] = http_request_number
    if http_request_uuid is not None:
        ordered_result["eo.meta.http-request-uuid"] = http_request_uuid
    if http_request_round_id is not None:
        ordered_result["eo.meta.http-request-round-id"] = http_request_round_id

    # ==================================================================
    # 3. Execution Environment / Timestamp Information
    # ==================================================================
    ordered_result["eo.meta.area"] = area
    if execution_id is not None:
        ordered_result["eo.meta.execution-id"] = execution_id
    if request_start_timestamp is not None:
        ordered_result["eo.meta.request-start-timestamp"] = request_start_timestamp
    if request_end_timestamp is not None:
        ordered_result["eo.meta.request-end-timestamp"] = request_end_timestamp

    # ==================================================================
    # 4. Protocol Information
    # ==================================================================
    ordered_result["eo.meta.http-protocol-version"] = protocol_value
    ordered_result["eo.meta.tls-version"] = tls_version_value

    # ==================================================================
    # 5. Extensions
    # ==================================================================
    extension_context = {
        "duration_ms": duration_ms,
        "Initial_Response_ms": Initial_Response_ms,
        "content_length_bytes": content_length_bytes,
        "target_url": target_url,
        "res_headers": res_headers,
        "redirect_count": redirect_count,
        "resource_info": resource_info,
        "retry_info": retry_info,
    }

    for ext_name in _EXTENSION_REGISTRY:
        ext_output = build_extension_output(ext_name, extension_context)
        ordered_result.update(ext_output)

    # ==================================================================
    # 9. Request Headers
    # ==================================================================
    for key in sorted(req_headers.keys()):
        ordered_result[f"headers.request-headers.{key.lower()}"] = req_headers[key]

    # ==================================================================
    # 10. Response Headers
    # ==================================================================
    for key in sorted(res_headers.keys()):
        ordered_result[f"headers.response-headers.{key.lower()}"] = res_headers[key]

    # ==================================================================
    # 11. Complement content-length header
    # ==================================================================
    if content_length_bytes is not None:
        cl_key = "headers.response-headers.content-length"
        if cl_key not in ordered_result or not ordered_result[cl_key]:
            ordered_result[cl_key] = str(content_length_bytes)

    return ordered_result